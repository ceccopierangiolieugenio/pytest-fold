import re
import pickle
from dataclasses import dataclass
from pathlib import Path
from strip_ansi import strip_ansi
from typing import Match

# Files generated by plugin.py
REPORTFILE = Path.cwd() / "report_objects.bin"
MARKEDTERMINALOUTPUTFILE = Path.cwd() / "marked_output.bin"
UNMARKEDTERMINALOUTPUTFILE = Path.cwd() / "unmarked_output.bin"

# regex matching patterns for Pytest sections
test_session_starts_matcher = re.compile(r"^==.*\stest session starts\s==+")
errors_section_matcher = re.compile(r"^==.*\sERRORS\s==+")
failures_section_matcher = re.compile(r"^==.*\sFAILURES\s==+")
warnings_summary_matcher = re.compile(r"^==.*\swarnings summary\s.*==+")
passes_section_matcher = re.compile(r"^==.*\sPASSES\s==+")
short_test_summary_matcher = re.compile(r"^==.*\sshort test summary info\s.*==+")
lastline_matcher = re.compile(r"^==.*in\s\d+.\d+s.*=+")

section_name_matcher = re.compile(r"~~>PYTEST_FOLD_(\w+)")
test_title_matcher = re.compile(r"__.*\s(.*)\s__+")

test_outcome_matcher = re.compile(
    r".*?::(.*?)\s(PASSED|FAILED|ERROR|SKIPPED|XFAIL|XPASS)\s.*?\[\s?.*?\]",
    re.MULTILINE | re.DOTALL,
)
test_session_starts_section_extra_space_matcher = re.compile(
    r".*::(.*)\s(PASSED|FAILED|ERROR|SKIPPED|XFAIL|XPASS)\s+.\[\s*.*\]"
)

MARKERS = {
    "pytest_fold_test_session_starts": "~~>PYTEST_FOLD_TEST_SESSION_STARTS<~~",
    "pytest_fold_errors_section": "~~>PYTEST_FOLD_ERRORS_SECTION<~~",
    "pytest_fold_failures_section": "~~>PYTEST_FOLD_FAILURES_SECTION<~~",
    "pytest_fold_warnings_summary": "~~>PYTEST_FOLD_WARNINGS_SUMMARY<~~",
    "pytest_fold_passes_section": "~~>PYTEST_FOLD_PASSES_SECTION<~~",
    "pytest_fold_short_test_summary": "~~>PYTEST_FOLD_SHORT_TEST_SUMMARY<~~",
    "pytest_fold_last_line": "~~>PYTEST_FOLD_LAST_LINE<~~",
}


@dataclass
class SectionInfo:
    """Info relevant to each Pytest output section"""

    name: str = ""
    label: str = ""
    matcher: Match = None
    content: str = r""


@dataclass
class TestInfo:
    """Info relevant for a single test"""

    title: str = ""
    category: str = ""
    outcome: str = ""
    caplog: str = ""
    capstderr: str = ""
    capstdout: str = ""
    text: str = ""
    keywords: set = ()


class Results:
    def __init__(self):
        self._reports = self._unpickle()
        self._unmarked_output = self._get_unmarked_output()
        self.Sections = self.init_sections()
        self._marked_output = MarkedSections(self.Sections)
        self.test_results = self.get_test_results()
        self.test_session_starts = self.Sections["TEST_SESSION_STARTS"].content
        self.last_line = self.Sections["LAST_LINE"].content

        # Group all test results by outcome
        self._categorize_tests()
        self.errors = self._get_result_by_outcome("ERROR")

        self.failures = self._get_result_by_outcome("FAILED")
        self.passes = self._get_result_by_outcome("PASSED")
        self.xfails = self._get_result_by_outcome("XFAIL")
        self.skipped = self._get_result_by_outcome("SKIPPED")
        self.xpasses = self._get_result_by_outcome("XPASS")

    def init_sections(self):
        return {
            "TEST_SESSION_STARTS": SectionInfo(
                name="TEST_SESSION_STARTS",
                label="Session Start",
                matcher=test_session_starts_matcher,
            ),
            "ERRORS_SECTION": SectionInfo(
                name="ERRORS_SECTION", label="Errors", matcher=errors_section_matcher
            ),
            "FAILURES_SECTION": SectionInfo(
                name="FAILURES_SECTION",
                label="Failures",
                matcher=failures_section_matcher,
            ),
            "WARNINGS_SUMMARY": SectionInfo(
                name="WARNINGS_SUMMARY",
                label="Warnings",
                matcher=warnings_summary_matcher,
            ),
            "PASSES_SECTION": SectionInfo(
                name="PASSES_SECTION", label="Passes", matcher=passes_section_matcher
            ),
            "SHORT_TEST_SUMMARY": SectionInfo(
                name="SHORT_TEST_SUMMARY",
                label="Short Test Summary",
                matcher=short_test_summary_matcher,
            ),
            "LAST_LINE": SectionInfo(
                name="LAST_LINE", label=None, matcher=lastline_matcher
            ),
        }

    def _update_test_result_by_testname(self, title: str, result: str) -> None:
        for test_result in self.test_results:
            if title == test_result.title:
                test_result.category = result

    def _categorize_tests(self) -> None:
        for line in self.test_session_starts.split("\n"):
            possible_match = re.search(test_outcome_matcher, strip_ansi(line))
            if possible_match:
                title = possible_match.groups()[0]
                outcome = possible_match.groups()[1]
                self._update_test_result_by_testname(title, outcome)

    def _get_result_by_outcome(self, outcome: str) -> None:
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            for test_result in self.test_results
            if test_result.category == outcome
        }

    def _get_unmarked_output(
        self, unmarked_file_path: Path = UNMARKEDTERMINALOUTPUTFILE
    ) -> list:
        with open(UNMARKEDTERMINALOUTPUTFILE, "r") as umfile:
            return umfile.read()

    def _unpickle(self):
        """Unpack pickled Pytest TestReport objects from file"""
        with open(REPORTFILE, "rb") as rfile:
            return pickle.load(rfile)

    def get_test_results(self):
        """Process TestReports from Pytest output and then remove duplicates"""
        processed_reports = self._process_reports()
        return list({item.title: item for item in processed_reports}.values())

    def _process_reports(self):
        """Extract individual test results from the pytest marked output"""
        test_infos = []
        for report in self._reports:
            test_info = TestInfo()

            # populate the TestInfo instance with pertinent data from report
            test_info.outcome = report.outcome
            test_info.caplog = report.caplog
            test_info.capstderr = report.capstderr
            test_info.capstdout = report.capstdout
            test_info.title = report.head_line
            test_info.keywords = set(report.keywords)

            # # get ANSI-coded text from marked sections
            # if test_info.category in ("failed", "passed"):
            #     try:
            #         test_info.text = self._marked_output.get_test_text_from_section2(
            #             test_info.title, "FAILED_TEST"
            #         )
            #     except:
            #         try:
            #             test_info.text = report.longreprtext
            #         except:
            #             test_info.text == ""
            # else:
            #     test_info.text == ""

            test_infos.append(test_info)
        return test_infos

    def get_errors(self):
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            for test_result in self.test_results
            if test_result.category == "error"
        }

    def get_failures(self):
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            + test_result.text
            for test_result in self.test_results
            if test_result.category == "failed"
        }

    def get_passes(self):
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            for test_result in self.test_results
            if test_result.category == "passed"
        }

    def get_xfails(self):
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            for test_result in self.test_results
            if test_result.category == "xfail" and "xfail" not in test_result.keywords
        }

    def get_xpasses(self):
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            for test_result in self.test_results
            if test_result.category == "passed" and "xfail" in test_result.keywords
        }

    def get_skipped(self):
        return {
            test_result.title: test_result.caplog
            + test_result.capstderr
            + test_result.capstdout
            for test_result in self.test_results
            if test_result.outcome == "skipped"
        }

    def get_results(self) -> list:
        return self.test_results

    def get_terminal_output(self) -> bytes:
        for section in self._marked_output._sections:
            if section.name == "TEST_SESSION_STARTS":
                return section.content

    def get_terminal_output2(self) -> bytes:
        for section in self._marked_output._sections:
            if section.name == "TEST_SESSION_STARTS":
                return section.content


class MarkedSections:
    """
    This class processes a Pytest output file that has been marked by pytest-fold,
    and identifies its sections. Pytest defines the following possible sections in
    its console output (not all show by default; they are dictated by option settings,
    e.g. in pytest.ini, on cmd line, etc.):

    "=== test session starts ==="
    "=== ERRORS ==="
    "=== FAILURES ==="
    "=== warnings summary ==="
    "=== PASSES ==="
    "=== short test summary info ==="
    "==== failed passed skipped xfailed xpassed warnings errors in 1.23s ==="
    """

    def __init__(
        self, Sections: dict, marked_file_path: Path = MARKEDTERMINALOUTPUTFILE
    ) -> None:
        self.Sections = Sections
        self._marked_lines = self._get_marked_lines(marked_file_path)
        self._sections = self._sectionize2(self._marked_lines)
        print("")

    def get_section(self, name: str) -> str:
        # return marked section, or if not found (e.g. didn't occur in output),
        # return blank dict w/ /no section content
        if name in self.Sections:
            return next(
                (section for section in self._sections if name == section.name),
                SectionInfo(),
            )
        else:
            raise NameError(f"Cannot retrieve section by name: '{name}'")

    def get_test_text_from_section2(self, name: str, section_name: str) -> str:
        # sourcery skip: use-next
        for section in self._sections:
            if section.name == section_name and name == section["test_title"]:
                return section.content
        return ""

    def _get_marked_lines(
        self, marked_file_path: Path = MARKEDTERMINALOUTPUTFILE
    ) -> list:
        """Return a list of all lines from the marked output file"""
        with open(MARKEDTERMINALOUTPUTFILE, "r") as mfile:
            return mfile.readlines()

    def _line_is_a_marker(self, line: str) -> bool:
        """Determine if the current line is a marker or part of Pytest output"""
        return (
            line.strip()
            in (
                MARKERS["pytest_fold_test_session_starts"],
                MARKERS["pytest_fold_errors_section"],
                MARKERS["pytest_fold_failures_section"],
                MARKERS["pytest_fold_passes_section"],
                MARKERS["pytest_fold_warnings_summary"],
                MARKERS["pytest_fold_short_test_summary"],
            )
            if line.strip()
            else False
        )

    def _sectionize2(self, lines: list) -> dict:
        """
        Parse marked lines from test run console output;
        build dictionary of SectionInfo objects
        """
        section_name = ""

        for line in lines:
            if self._line_is_a_marker(line):
                section_name = re.search(section_name_matcher, line).groups()[0]
                self.Sections[section_name].content = r""
            else:
                self.Sections[section_name].content += line
        self.Sections["LAST_LINE"].content = lines[-1]
        return self.Sections
